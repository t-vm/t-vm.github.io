<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Thinkpad X201i - 关于我人生中被Hackintosh吃掉的五天</title>
    <link href="/2024/07/28/Thinkpad%20X201i%20-%20%E5%85%B3%E4%BA%8E%E6%88%91%E4%BA%BA%E7%94%9F%E4%B8%AD%E8%A2%ABHackintosh%E5%90%83%E6%8E%89%E7%9A%84%E4%BA%94%E5%A4%A9/"/>
    <url>/2024/07/28/Thinkpad%20X201i%20-%20%E5%85%B3%E4%BA%8E%E6%88%91%E4%BA%BA%E7%94%9F%E4%B8%AD%E8%A2%ABHackintosh%E5%90%83%E6%8E%89%E7%9A%84%E4%BA%94%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>诚如某位<a href="https://space.bilibili.com/316568752?spm_id_from=333.337.0.0">光头</a>所言,  凡事讲前应先下定义.<br>对得很, 我们现在就来给Mac用户的等级下定义:</p><ol><li><strong>刹地利</strong>: 正宗Mac电脑用户. 他们或使用MacBook或使用iMac(如果是Mac stutio等workstation就更高雅了), 正如Apple所言, 拿着wonderful tools. 做着wonderful things.</li><li><strong>吠舍</strong>: 使用Mac mini乞丐版&#x2F; MacBook Air 2020(m1, 某多多4k拿下)的用户, 他们只是对macOS好奇, 浅尝辄止,又或是只想拿一台廉价水果标电脑装邪逼. 这类人群的行为看似是使用Mac,  实则是对Mac的大不敬</li><li><strong>首陀罗</strong>: 使用Mac硬件安装其它操作系统的用户. 如果上一类人只是对Mac不敬, 那么这类人就是对Mac的玷污. 他们手握预装了优雅的macOS的设备, 却向其中注入污秽不堪的windows或无比简陋、缺胳膊少腿的各类*nix(注: macOS除外), 竟还用得不亦乐乎! 还好, Apple silicon已经为这类人降下了神罚:  bootcamp似了! 这是历史性的胜利, <a href="https://zh.wikipedia.org/zh-hk/Arm_(%E4%BC%81%E6%A5%AD)">圣Apple在1990年射出的箭</a>, 2020年正中靶心, 摧毁了这群人最阴暗的欲望. 所以他们只能以最低级的奴仆身份存活.</li><li><strong>达利特</strong>: 使用其它厂商的无聊硬件和弗兰肯斯坦diy主机的各种Linux发行版用户和windows用户. 对于任何等级的Mac用户来说, 他们都是绝对的不可接触者.</li></ol><p>这时候有人就要问了, 是不是少了什么东西?</p><ul><li>那么请问, <strong>婆罗门</strong>是什么?</li></ul><p>好问题, 但答案也显而易见:</p><ul><li><em><strong>婆罗门就是hackintosh用户</strong></em></li></ul><p>尽管他们使用劣质的非Apple硬件, 但是却仍然向往macOS, 虽然肉体贫穷, 但精神富足. 这就是Mac用户中的“一箪食一瓢饮在陋巷”.<br>他们中还有一些人是希望在自定义的高配硬件上使用macOS, 这也是一种大智慧, 为了满足自己的、位于马斯洛需求层次最高层的超越需求,(即是最优化macOS性能体验)不惜借用肮脏的魔鬼的力量, 并操控自如、不僭越.<br>hackintosh用户在当前的体系中是婆罗门, 而在另一种文化语境下, 他们又可以是使徒(ἀπόστολος), 是拥有着各种使命的、圣Apple的最忠诚的门徒.</p><p>作为一个立志成为婆罗门的Mac用户, 本人当然也知晓上面的一切. 但我却总是有一些世俗的欲望: 比如收集一些旧硬件折腾着玩儿. 这本没什么问题, 但它们中的一些是非 <em>Designed by Apple in California</em>的. 显然这违反了有这种志向的人群应有的优雅生活范式.</p><h2 id="一个月黑风高的晚上"><a href="#一个月黑风高的晚上" class="headerlink" title="一个月黑风高的晚上"></a>一个月黑风高的晚上</h2><p>闲鱼出现200元不到的 x201i, 三大件配置如下:</p><ul><li>i5 m450</li><li>8GB DDR3 1600MHz</li><li>128GB SSD<br>尽管201i是201的猴版, 但这台机器成色不错. 此前便对这型机器比较有兴趣的我用手摸了摸下巴, 对着商品详情页里充斥着摩尔纹的参数表屏摄照片思考:</li><li>32nm的1st Gen i5, 性能放在今天看个网页写个脚本弄弄ssh还是够用的, 缺点是比较烫</li><li>8G 1600已经是这颗处理器能上的最高规格了, 什么, 寨条? 唉寨就寨呗,反正是内存</li><li>这种二手旧电脑里的ssd包杂牌的,肯定要换. 都这价格了就当送个u盘. 嚯, 套个十块钱的优〇者或者〇联还能是usb3.0<br>想到这里遂拿下.<br>于是在我的世俗欲望作祟下, 我又一次购买了非Apple硬件 – 破戒了.</li></ul><h3 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h3><p>此时此刻的我当然不知道这就是一切破事的开端, 在上述动作带来的多巴胺驱使下点开闲鱼和pdd又购买了:</p><ul><li>原装拆机键盘一副: 直觉告诉我这台机器键盘可能有故障</li><li>IBM Thinkpad 金属贴若干: 本人无限回购的小东西之一, 贴在各种设备上. 这是我第一次收2005年后的小黑, 就用这个金属贴当作201i成为荣誉马莱人的证明</li><li>512G长城ssd(sata): 199包邮带三年质保, 什么性能不性能的, 还能比原装2.5‘’ hdd慢?</li></ul><p>差不多就这些, 这台机器我还是想拿来正儿八经用用的, 吃的好点也无妨.<br>于是不知不觉钱包-400的我就这么睡了. 啊啊, 这就是消费主义</p><h2 id="算盘珠子"><a href="#算盘珠子" class="headerlink" title="算盘珠子"></a>算盘珠子</h2><p>机器买到了, 装什么系统?<br>本人一直立志成为婆罗门, 前面已经说过了. 这没什么特别, 毕竟做题十二年, 那股惯性怼着我十分向往自己能够力争上游, 冲向四大种姓之巅.<br>一个念头萌生在这一时刻的我的脑内:</p><blockquote><p>都说没有tp黑不了的苹果, 要不我这次也试试?</p></blockquote><p>我开心的很. 我觉得使用hackintosh一跃成为婆罗门, 这爽感简直堪比做题做上清北!</p><p>要不就Catalina吧!<br>我早就想再用用Catalina. 高中毕业后卖掉了那台陪伴我多年的mbp13, 后悔得很.</p><h2 id="面子"><a href="#面子" class="headerlink" title="面子"></a>面子</h2><p>day1下午, 阴天.<br>键盘好好的, 15块钱的拆机键盘算是白买了.<br>不过没关系, 此刻的我打开电脑开始收集相关文档和资源<br>颅内os:  </p><ol><li>装系统是只要是电脑用的多一点的人都掌握的技能</li><li>装hackintosh是装系统</li></ol><ul><li>所以再怎么说也是个cs学生,  再怎么说也不过是装个系统, <strong>天黑之前搞定</strong><br>Q.E.D.</li></ul><p>大概看了一下clover的文档以及相关的文件结构, 便开始上手操作.</p><p>day2 凌晨3:00<br>傻眼了: 发现EFI难配得很. 自己搞出来的东西不是代码跑一半卡死就是kernel panic, 更不用说一开始搞出来的安装介质压根就不能引导, 漆黑的屏幕上只剩一个光标在左上角跳动, 基本上就是在嘲讽映在它旁边的那张脸: 你什么身份, 这么简单就想碰瓷婆罗门?<br>果然如此. 我体内的十二年做题基因正提醒我你不做题还想考大学, 谁给你的胆子? </p><blockquote><p>事已至此, 先睡觉吧</p></blockquote><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>day2下午<br>算是想开了: 近20年过去, 黑苹果这东西已经发展出了自己的一套技术体系, 不论是clover还是opencore, 都不是花一两天能从啥也不会掌握到自己从零开始配置config和一堆kexts的程度的东西.</p><ul><li>免责声明: 至少我不能</li></ul><p>所以哪有不抄作业的道理! </p><p>中学时代和10.12-10.15打交道的时期现在是粉红色泡泡里的good old days, 10.15成堆的黑屏死机和五国报错就当不存在, 我要装10.15! 此时的我俨然一副<strong>守序中立</strong>的姿态: 直接从头抄到尾, 今天天黑之前用上Catalina.<br><a href="https://github.com/t-vm/Thinkpad-X201-Hackintosh-Catalina">gayhub上恰好有个repo是给x201装10.15</a>.<br>x201i和x201除了重量、扬声器、cpu和网卡之外基本没有区别.  </p><ul><li>CPU: 我手上这台201i是小皇帝版, 除了主频低一些之外和i5的x201差别不大, 更何况只要是同一代的话CPU这块就没什么影响</li><li>网卡: 所有型号的201i都是丐中丐1000BGN无线网卡. 终归是要换, 问题不大<br>直接开抄, 发现这个repo中的教程有一些问题.如果一板一眼按照教程来后果就是你的安装介质甚至不能正常boot.</li></ul><p>day3<br>本日通宵<br>首先是一番排障:</p><ul><li>镜像本身没什么问题, 这个镜像大家用了都说好</li><li>原repo中没有提及clover安装器, 反而是一个issue中指出了这个问题. 经过一番查证我发现这个东西还是有必要的, 并不是很多帖子说的直接将EFI文件夹拖到EFI分区就可以. 而clover版本这块是个玄学, 应该多尝试几个版本.</li><li>原repo中的<code>config.plist</code>不能正常使用, 这个是上个问题解决后才发现的. 鉴于原作者能够正常使用, 我猜测他是移除了一些个性化设置后才push了这个文件. (后来我发现他的README中也提了一嘴</li></ul><h3 id="安装流程补完"><a href="#安装流程补完" class="headerlink" title="安装流程补完"></a>安装流程补完</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/Catalina.png?raw=true" alt="Catalina"></p><ul><li>试了多次后, 发现clover的5107版本最有效. (我觉得应该有更有效的)</li><li>原repo中的config移除了一些序列号之类的让你自己生成. 但问题是作者把于机型而非设备对应的主板序号也删除了.没关系, 我们有everymac, 可以查询到.</li></ul><p>经过折腾, 大概总结出了一个比较完整的流程和一个更完整的<code>config.plist</code>. 我在整件事结束后把它push到gayhub并联系原作者merge到了原repo. 这里就不再赘述.<br>    <a href="https://github.com/jamesfawcett/Thinkpad-X201-Hackintosh-Catalina">嘿, 链接在这儿</a></p><p>有一点要说一下, 把u盘当作安装盘之前务必要拿diskgenius之类的东西删除其中所有的分区, 再格式化成macOS extend(journalized), GUID分区图.</p><h2 id="混乱邪恶"><a href="#混乱邪恶" class="headerlink" title="混乱邪恶"></a>混乱邪恶</h2><p>问题果然还是出现了. 对于macOS10.15而言, 第一代酷睿i系列的<code>Arrandale</code> 平台核显无法原生驱动,因为采用这些cpu的MacBook Pro6,2(Mid 2010)已经在10.13之后被淘汰了. 所以我们需要自己打补丁. 这本身没什么问题, 是各大hackintosh&#x2F; legacy Mac 论坛的保留节目.<br>但是整个day3就这么结束了:</p><ul><li>原repo中的post-install方法不起作用</li></ul><p>这天剩下的时间里我一直在找打补丁的方法. 期间把系统摧毁了两次, 还装了一次10.14. 但问题都没有得到解决.此时的我已经心力交瘁, 不知道该如何是好.<br>(事后回想, 这很可能是我的问题, 原repo中的post- install流程应该是可以用的, 也许我没有注意到一些细节问题)</p><h3 id="繁文缛节"><a href="#繁文缛节" class="headerlink" title="繁文缛节"></a>繁文缛节</h3><p>事实上, 一直有<a href="https://github.com/jtaczanowski/ThinkPad-X201-Arrandale-macOS-OpenCore">一个很不错的repo</a>, 也是给x201系列安装hackintosh, 但是macOS11. 我一直没用它是因为:</p><ol><li>守序中立, 对10.15的执念</li><li>它使用OpenCore作为bootloader, 尽管这玩意是当下的趋势, 但我折腾了三天一直都在用clover.</li></ol><p>但考虑到:</p><ol><li>我已经对10.15绝望</li><li><strong>只要使用hackintosh就是婆罗门</strong><br>没错, 根据我们上面的定义, 只要装上hackintoh就是婆罗门, 就可以登上Mac用户鄙视链之巅. 版本嘛无所谓的. 之前不还试了一下10.14吗? 对于10.15忠诚不绝对就是绝对不忠诚, 让我们摒弃繁文缛节转向OC和macOS11</li></ol><h3 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h3><p>day4<br>基本就是按照作业里的流程开抄.<br>首先是版本的问题. 我按照流程制作好的安装介质在boot过程中会报错:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">000</span> <span class="hljs-number">00</span>:<span class="hljs-number">000</span> OCS: No schema for Block at <span class="hljs-number">0</span> index, context &lt;Emulate&gt;!<br><span class="hljs-attribute">00</span>:<span class="hljs-number">114</span> <span class="hljs-number">00</span>:<span class="hljs-number">114</span> OC: Driver HfsPlusLegacy.efi at <span class="hljs-number">3</span> cannot be loaded - Volume Corrupt!<br></code></pre></td></tr></table></figure><p><code>HfsPlusLegacy.efi</code>没法正确加载. 大家都知道, 出现报错是好事, 特别是当你能理解它报了个啥的时候.<br>这东西位于OC整个包的.<code>./Volume</code>目录下, 根据经验我认为我应该把整个OC换掉, 换成另一个版本. 我根据这个hackintosh的repo第一次push的时间找到了那附近发行的OpenCore版本<code>0.8.5</code>. 然后重新做了一遍安装介质. 这次可以正确引导了.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>其实装macOS11的过程中只遇到了一个问题<br>当从安装介质跑完安装器的进度条, 重新启动从硬盘安装的时候, 进度条每次都会从“剩余29分钟”开始, 读到“剩余26分钟”左右时, 砰,电脑自动关机了.<br>第一次遇到这种情况的时候我当然没当回事儿. 众所周知macOS安装过程中重启几次是很正常的.<br>但是每当我重新打开电脑, 进入安装器, 同样的事情又会再次发生.</p><ul><li>好得很, 现在我也是loop系作品的主角了!</li></ul><p>很快我意识到并不是这样. 倒不是因为问题被解决, 而是有时候干脆都不会进入安装器, 电脑直接就黑屏了.就这样重复了不知道多少次, 没有任何进展.<br>在repo中提issue, 只有一个人回复, 还是之前10.15的repo的那位原作者. 但很遗憾, 他的回复并没有解决问题. 或者说, 是我问的有问题. 此时此刻的我以为这还是OC出了问题,使用的版本不对之类的, 毕竟有前车之鉴,而且这个警告还在:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">OCS:</span> No <span class="hljs-keyword">schema </span>for <span class="hljs-keyword">Block </span><span class="hljs-built_in">at</span> <span class="hljs-number">0</span> index, <span class="hljs-built_in">context</span> &lt;Emulate&gt;!<br></code></pre></td></tr></table></figure><p>于是我在issue中提出想要知道这个repo中所使用的OC的版本.</p><p>那位老哥在回复中告诉我版本是<code>0.8.0</code>.于是我便使用这个版本第三次制作了安装介质, 仍然不行,  还是同样的问题. 结论是和OC的版本无关.至于那条警告, 我得知它基本上是可以忽略的, 基本上就是一个被弃用的config编辑器的锅.<br>接下来我进行了许多尝试, 比如:</p><ul><li>更换系统镜像</li><li>更换作为安装介质的u盘</li><li><code>nvram -c</code></li><li>拔电池放电, 然后面<em>One Apple Park Way ,Cupertino, CA 95014</em><a href="">1</a>而拜, 圣Apple, 求求你, 我也想要成为hackintosh用户, <strong>婆罗门になりたいうた!</strong></li></ul><p>果然这些尝试都没什么用. 生无可恋的我在某次安装中一边失去高光对着屏幕发呆一边无意义的按键盘.<br>结果没想到进度条下面的文字不知不觉中变成了“还剩25分钟”, 跨越了26分钟的死亡之墙. 本西西弗斯顿时意识到石头即将滑下去前的那一瞬间又往上移动了一点点.<br>我索性继续胡乱按键盘, 结果进度条也就这样持续走着.<br>西西弗斯看到石头突然长出来几个矢量喷嘴直接从山上起飞了.</p><p>我突然明白了一件事,  这个macOS11在安装的时候不知怎的也会有挂起机制, 大概三分钟左右会熄屏. 而对于hackintosh而言如何解决笔记本睡眠一直是个老大难问题, X201也是一样. 我猜自动关机这个状况就是挂起然后一睡不醒了.<br>我们常说人一般会优先选择最简单最愚蠢但不需要多加思考的解决方案, 手边有什么就优先用什么, it just works. 所以我选择在安装结束前的二十分钟里一直不停的按键盘防止电脑挂起.</p><blockquote><p>这期间我一直在反复观看<a href="https://www.bilibili.com/video/BV1bM4m1Z7Y9/?share_source=copy_web&vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63">clumsy trick</a> 和 <a href="https://www.bilibili.com/video/BV15E421j7Bu/?share_source=copy_web&vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63">Luna say maybe</a>, 听说看了都说好, 赶快和我一起观看吧!</p></blockquote><p>然后一步步走就可以完成安装了.要注意初始化系统设置的过程中的图形特别慢, 因为我们的显卡还没有去动起来. 之后的过程很是简单, 使用原repo中提供的post install软件即可, 开箱即用无需任何操作, 然后我们的工作就圆满完成了.<br>这时候我已经溜大了, 已经爽飞了, 而那石头也继续飞在空中, 伸出来两条胳膊还拿着把贝斯, 对我吼道:</p><blockquote><p>“操的, 好几把摇滚”</p></blockquote><ul><li>VTOL石头, best石头! – by 西西弗斯</li></ul><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>越努力越幸运, 拼搏五天, 我要成为婆罗门. 这时候本人已经半步踏入了Mac婆罗门的门槛, 可喜可贺.<br>在以凡人之躯和神沟通, 呼吸香甜的空气之前, 还有一个小小的障碍亟待解决 – 网卡.</p><p>还记得我们的丐中丐1000BGN吗 ?它无法直接被驱动. 这种低劣的硬件很显然是不配被圣macOS调用的. 折腾这种挡在我们的成婆之路前面的东西就好比高三下学期三轮复习的时候还在做出的很烂的送分题, 只能耽误自己成为做题大手子, 这叫做假努力.</p><p>所以我掏出了免驱神卡BCM94360HMB,不仅性能不错且原生支持macOS的各项功能. 它就像班里前几名的如假包换做题大手子考前人手一册的那种提纲&#x2F;习题集, 折腾这种东西才有意义, 助你在现实中也成为学历婆罗门.<br>有一点需要注意, 这张卡是IPEX4天线座, 对于X201系列来说, 我们需要两根IPEX1toIPEX4的转接线才能安装.安装的时候, 灰色的线在上方, 对应J3天线座.<br>由于硬件白名单的存在, 这张卡不兼容2015年前的Thinkpad. 不过我们有成熟的解决方案, 可以轻松烧录新的bios去掉这个白名单的限制, 无需拆机无需编程器. 插上PE盘启动我们的小黑, 打开<a href="https://li-aaron.github.io/2020/02/thinkpadx201i-refresh-2/">这位朋友整理的工具包</a>无脑跟着做即可. </p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>一切就绪后我们有可能会发现还是无法联网, 比如我. 这时候让我们进一步采取措施:</p><h4 id="挣扎"><a href="#挣扎" class="headerlink" title="挣扎"></a>挣扎</h4><p>打开系统信息, 在Wi-Fi项看一下网卡名称, 一般是<code>en0</code>或者<code>en1</code>. 我是后者, 所以我以后者为例.<br>终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ifconfig en1 down<br></code></pre></td></tr></table></figure><p>关闭无线网卡,然后是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ifconfig en1 up<br></code></pre></td></tr></table></figure><p>再启用它.<br>这时候如果可以了, 那么恭喜你, 你是幸运儿.</p><h4 id="偏方"><a href="#偏方" class="headerlink" title="偏方"></a>偏方</h4><p>如果你在看这个部分, 那么我估计上面的命令你早就已经试过了, 然并卵. 这时候其实我也没有什么正经方法了. 但是你要问我是怎么救活的, 还真就是个偏方:</p><ol><li>捡起你扔在一边的安装盘插入电脑, 开机, 从它启动安装器<code>Install macOS Big Sur</code>.</li><li>联网. 是的, 一般来说可以.</li><li>打开safari随便开个网页确认下</li><li>关机, 拔掉安装盘, 正常启动硬盘中的系统</li></ol><h2 id="看看机器"><a href="#看看机器" class="headerlink" title="看看机器"></a>看看机器</h2><p>最后我们来看看机器的全貌吧</p><h3 id="A面"><a href="#A面" class="headerlink" title="A面"></a>A面</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/a.png?raw=true" alt="那还是三色标比较对味"></p><ul><li>天杀的类肤质</li></ul><h3 id="B-C"><a href="#B-C" class="headerlink" title="B&amp;C"></a>B&amp;C</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/x201i.png?raw=true" alt=" 那还是三色标比较对味"></p><ul><li>奔4贴纸买多了, 贴一下</li><li>我都贴三色标了那Lenovo也别留了(尽管收购初期也确实有x60之类同时印着这两者的产品), 拿个psp替换壳带的贴纸糊上, 还挺像那么回事</li></ul><h3 id="D面"><a href="#D面" class="headerlink" title="D面"></a>D面</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/d.png?raw=true" alt="老TP优秀的D面设计, 拆装起来简直就是享受"></p><ul><li>可以看到键盘的防泼溅设计: D面有三个方形的键盘排水口</li><li>可轻松拆卸的电池. 本人认为今天的电脑缺少这种设计是所有厂商的罪过: <del>你tm又不是三防机!</del></li><li>扩展坞接口. 如果以后遇到白菜价底座或许会买一个试试能不能在macOS 下使用. X200&#x2F;201系列的扩展坞是可以额外装一块电池的, 如果里面有风扇能压一压这个大火炉就更好了.这种底座式扩展坞搭载额外的散热组件绝对是很酷的一件事.</li></ul><h3 id="左侧"><a href="#左侧" class="headerlink" title="左侧"></a>左侧</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/l.png?raw=true" alt="left"><br>从左到右分别为: </p><ul><li>电源接口</li><li>USB2.0</li><li>VGA</li><li>RJ45</li><li>三个东西扎堆<ul><li>ExpressCard插槽</li><li>USB2.0(黄色, 关机时仍可从电池取电)</li><li>无线开关</li></ul></li></ul><h3 id="右侧"><a href="#右侧" class="headerlink" title="右侧"></a>右侧</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/r.png?raw=true" alt="right"></p><p>从左到右分别为:</p><ul><li>USB2.0</li><li>耳机插口</li><li>麦克风插口</li><li>哈基米是调制解调器的意思</li><li>硬盘盖板(内部带快拆托架)</li><li>锁孔</li></ul><h3 id="正面"><a href="#正面" class="headerlink" title="正面"></a>正面</h3><p><img src="https://github.com/t-vm/img_hosting/blob/main/24_7/f.png?raw=true" alt="front"></p><ul><li>锁扣和SD卡插槽</li></ul><h2 id="休息一下"><a href="#休息一下" class="headerlink" title="休息一下"></a>休息一下</h2><p>到这里, 作为一个此前从未接触hackintosh的、尚没有脱离低级趣味的人, 我为期五天的折腾算是完成了. 目前存在的一个问题是<code>control</code>键始终默认开启粘滞键且无法取消, 以及小红点灵敏度过高十分鬼畜, 有时候还会掉驱动. 后一个问题似乎是无解的. 至于无法合盖睡眠之类的我就不管了. 总的来说这机器目前可以投入使用.</p><p>这次能给各位朋友的最大建议就是: 务必在确定自己需要安装macOS后再根据兼容性挑选硬件, 而不是反过来. </p><p>什么? 你说day5我在干什么? 那当然是在写这篇文章.  btw, 很显然我现在已经是一个脱离了低级趣味的、正统的Mac婆罗门了.<br>最后祝大家身体健康, 再见</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>X201安装Catalina项目repo: <a href="https://github.com/jamesfawcett/Thinkpad-X201-Hackintosh-Catalina">https://github.com/jamesfawcett/Thinkpad-X201-Hackintosh-Catalina</a></li><li>X201安装Big sur项目repo: <a href="https://github.com/jtaczanowski/ThinkPad-X201-Arrandale-macOS-OpenCore">https://github.com/jtaczanowski/ThinkPad-X201-Arrandale-macOS-OpenCore</a></li><li>X201i刷BIOS:<a href="https://li-aaron.github.io/2020/02/thinkpadx201i-refresh-2/">https://li-aaron.github.io/2020/02/thinkpadx201i-refresh-2/</a></li><li>opencore入门: <a href="https://dortania.github.io/OpenCore-Install-Guide/">https://dortania.github.io/OpenCore-Install-Guide/</a></li><li>opencore入门(中文): <a href="https://thrrip.github.io/OpenCore-Install-Guide/prerequisites.html">https://thrrip.github.io/OpenCore-Install-Guide/prerequisites.html</a></li><li>EveryMac: <a href="https://everymac.com/">https://everymac.com</a></li><li>ARM: <a href="https://zh.wikipedia.org/zh-cn/Arm_(%E4%BC%81%E6%A5%AD)">https://zh.wikipedia.org/zh-cn/Arm_(企業)</a></li><li>【【睡前消息541】社会化抚养概论】 <a href="https://www.bilibili.com/video/BV1ED4y1n7MD/?share_source=copy_web&vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63">https://www.bilibili.com/video/BV1ED4y1n7MD/?share_source=copy_web&amp;vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63</a></li><li>【【中字cc】初星学園 「Luna say maybe」Official Music Video】 <a href="https://www.bilibili.com/video/BV15E421j7Bu/?share_source=copy_web&vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63">https://www.bilibili.com/video/BV15E421j7Bu/?share_source=copy_web&amp;vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63</a></li><li>【【中字cc】初星学園  「clumsy trick」Official Music Video】 <a href="https://www.bilibili.com/video/BV1bM4m1Z7Y9/?share_source=copy_web&vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63">https://www.bilibili.com/video/BV1bM4m1Z7Y9/?share_source=copy_web&amp;vd_source=fb5c2700f1bfa08d8c59fe69e79a7f63</a></li></ol><h2 id="请注意…"><a href="#请注意…" class="headerlink" title="请注意…"></a>请注意…</h2><p>本blog中的所有内容均不会用于商业用途. 但如果您不认为自己的作品应该出现在这里, 请联系我删除.</p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>hackintosh</tag>
      
      <tag>折腾</tag>
      
      <tag>hardware</tag>
      
      <tag>software</tag>
      
      <tag>发电</tag>
      
      <tag>电子垃圾colle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 File Handling</title>
    <link href="/2024/03/08/Python3-File-Handling/"/>
    <url>/2024/03/08/Python3-File-Handling/</url>
    
    <content type="html"><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>这部分内容有时挺易混的, 故整理出本文作备忘录使用<br>本文缝了一大堆东西, 它们来自官方文档、网络和自己大一大二时零零散散的笔记.<br>以下内容基于: Python3.11</p><h1 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h1><p>我觉得<a href="https://www.freecodecamp.org/chinese/news/file-handling-in-python/">这里</a>总结得比我好, 而且这块内容实际应用的时候基本不会出什么大问题, 绝无可能是我懒得写.</p><p>tips: read开头的三个方法的区别:<br><code>read()</code>如果没有指定字节数, 就读取全部<br><code>readline()</code>返回一行<br><code>readlines()</code>返回所有行构成的的<strong>列表</strong></p><h1 id="序列化与反序列化-使用pickle"><a href="#序列化与反序列化-使用pickle" class="headerlink" title="序列化与反序列化(使用pickle)"></a>序列化与反序列化(使用pickle)</h1><h2 id="pickle特性"><a href="#pickle特性" class="headerlink" title="pickle特性"></a>pickle特性</h2><ul><li>快, 但不安全(无加密, 无数字签名)</li><li>简单好使</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="使用pickle-dump-和pickle-load"><a href="#使用pickle-dump-和pickle-load" class="headerlink" title="使用pickle.dump()和pickle.load()"></a>使用<code>pickle.dump()</code>和<code>pickle.load()</code></h3><h4 id="写二进制文件-pickle-dump-obj-file"><a href="#写二进制文件-pickle-dump-obj-file" class="headerlink" title="写二进制文件: pickle.dump(obj, file)"></a>写二进制文件: pickle.dump(obj, file)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pickle.dump(_obj_, _file_, _protocol=None_, _*_, _fix_imports=True_, _buffer_callback=None_)<br></code></pre></td></tr></table></figure><blockquote><p>它等同于 <code>Pickler(file,protocol).dump(obj)</code>。</p></blockquote><p>将对象 <code>obj </code>封存以后写入已打开的file object <code>file</code>.<br><strong>我就经常干蠢事: 忘记要先使用<code>open()</code>等方法打开文件再进行序列化</strong></p><h4 id="读二进制文件-pickle-load-file"><a href="#读二进制文件-pickle-load-file" class="headerlink" title="读二进制文件: pickle.load(file)"></a>读二进制文件: pickle.load(file)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pickle.load(_file_, _*_, _fix_imports=True_, _encoding=<span class="hljs-string">&#x27;ASCII&#x27;</span>_, _errors=<span class="hljs-string">&#x27;strict&#x27;</span>_, _buffers=None_)<br></code></pre></td></tr></table></figure><blockquote><p>它相当于 <code>Unpickler(file).load()</code>。</p></blockquote><p>从已打开的 file object 中读取封存后的对象，<em>重建</em>其中特定对象的层次结构并返回.</p><p>Pickle 协议版本是自动检测出来的，所以一般<strong>不需要</strong>参数来指定协议。封存对象以外的其他字节将被忽略。</p><h3 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h3><p>这两个函数用于将对象序列化<strong>到文件</strong>或<strong>从文件</strong>中反序列化对象。<br>原始数据: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>序列化到文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;serialized_data.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:         <br>pickle.dump(data, f)<br></code></pre></td></tr></table></figure><p>将<code>data</code>对象序列化到名为<code>serialized_data.pkl</code>的文件中。</p><p><strong>从文件中反序列化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;serialized_data.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:    <br>data_from_file = pickle.load(f)<br></code></pre></td></tr></table></figure><p>从文件<code>serialized_data.pkl</code>中读取并反序列化对象。</p><p>本例中，从文件中加载的数据输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="补充-直接操作-不涉及文件"><a href="#补充-直接操作-不涉及文件" class="headerlink" title="补充: 直接操作(不涉及文件)"></a>补充: 直接操作(不涉及文件)</h2><p>使用<code>pickle.dumps()</code>和<code>pickle.loads()</code><br>这两个函数直接在内存中操作，<strong>不涉及文件系统</strong>. 也算是比较常用.<br>直接用例子:</p><p><strong>原始数据</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>序列化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">serialized_data = pickle.dumps(data)<br></code></pre></td></tr></table></figure><p>python对象<code>data</code>被序列化为<em><strong>字节对象</strong></em><code>serialized_data</code>。</p><p> <strong>反序列化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">deserialized_data = pickle.loads(serialized_data)<br></code></pre></td></tr></table></figure><p><em><strong>字节对象</strong></em><code>serialized_data</code>被反序列化为<strong>原始的Python对象</strong><code>deserialized_data</code>。</p><p>本例中，输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Serialized with dumps(): </span><br><span class="hljs-string">b&#x27;\x80\x04\x95\x17\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x01a\x94K\x01\x8c\x01b\x94K\x02\x8c\x01c\x94K\x03u.</span><br><span class="hljs-string"># Deserialized with loads(): </span><br><span class="hljs-string">&#123;&#x27;</span>a<span class="hljs-string">&#x27;: 1, &#x27;</span><span class="hljs-string">b&#x27;: 2, &#x27;</span>c<span class="hljs-string">&#x27;: 3&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到<code>dumps()</code>之后直接就是bytes类型, 存储在变量<code>serialized_data</code>中.</p><h1 id="压缩与解压缩-使用gzip"><a href="#压缩与解压缩-使用gzip" class="headerlink" title="压缩与解压缩(使用gzip)"></a>压缩与解压缩(使用gzip)</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="读压缩文件-gzip-open-filename-str-mode-str"><a href="#读压缩文件-gzip-open-filename-str-mode-str" class="headerlink" title="读压缩文件: gzip.open(filename:str, mode: str)"></a>读压缩文件: gzip.open(filename:str, mode: str)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">gzip.<span class="hljs-built_in">open</span>(_filename_, _mode=<span class="hljs-string">&#x27;rb&#x27;</span>_, _compresslevel=9_, _encoding=None_, _errors=None_, _newline=None_)<br></code></pre></td></tr></table></figure><p>以二进制方式或者文本方式打开一个 gzip 格式的压缩文件，返回一个file object.</p><p><code>filename</code> 参数可以是一个实际的文件名，或者是一个<em><strong>用来读写的已存在的文件对象。</strong></em></p><p><code>mode</code> 参数可以是二进制模式： <code>&#39;r&#39;</code>, <code>&#39;rb&#39;</code>, <code>&#39;a&#39;</code>, <code>&#39;ab&#39;</code>, <code>&#39;w&#39;</code>, <code>&#39;wb&#39;</code>, <code>&#39;x&#39;</code> or <code>&#39;xb&#39;</code> <br>也可以是文本模式 <code>&#39;rt&#39;</code>, <code>&#39;at&#39;</code>, <code>&#39;wt&#39;</code>, or <code>&#39;xt&#39;</code>。默认值是 <code>&#39;rb&#39;</code>。</p><h4 id="写压缩文件"><a href="#写压缩文件" class="headerlink" title="写压缩文件"></a>写压缩文件</h4><p>使用<code>gzip.open()</code>打开压缩文件后得到文件对象, 使用诸如<code>write()</code>等方法正常写入即可.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取压缩文件：</span><br><span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/path/to/file/file.txt.gz&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    file_content = f.read()<br><br><span class="hljs-comment"># 创建GZIP文件</span><br>content = <span class="hljs-string">b&quot;contents&quot;</span><br><span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/path/to/file/file.txt.gz&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(content)<br><br><span class="hljs-comment"># 使用GZIP压缩已打开的文件对象</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/path/to/file/file.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f_in:<br>    <span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/path/to/file/file.txt.gz&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f_out:<br>    cont = f_in.read()<br>f_out.write(cont)<br></code></pre></td></tr></table></figure><h1 id="文件指针操作-seek-offset"><a href="#文件指针操作-seek-offset" class="headerlink" title="文件指针操作: seek(offset)"></a>文件指针操作: seek(offset)</h1><p><strong>seek()</strong> 方法用于移动文件读取指针到指定位置。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fileObject.seek(offset[, whence])<br></code></pre></td></tr></table></figure><p>fileObject可以是任何已经存在的用来读写的文件对象</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><strong>offset</strong> – 开始的<em><strong>偏移量</strong></em>，也就是代表需要移动偏移的字节数</li><li><strong>whence：</strong>  <em><strong>可选</strong></em>，默认值为 0。给offset参数一个定义，表示要从哪个位置开始偏移:<ul><li>0代表从文件开头开始算起，</li><li>1代表从当前位置开始算起</li><li>2代表从文件末尾算起。</li></ul></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果操作成功，则返回新的文件位置，如果操作失败，则函数返回 -1。</p><h1 id="shelve-模块"><a href="#shelve-模块" class="headerlink" title="shelve 模块"></a>shelve 模块</h1><p>(这部分用的比较少, 原始笔记里有, 我删了)<br>通过<code>shelve.open()</code>方法打开一个shelve对象后，就可以使用<strong>类似字典</strong>的方式操作这个对象中的键值对.<br>具体用法省略</p><h1 id="请注意…"><a href="#请注意…" class="headerlink" title="请注意…"></a>请注意…</h1><p><strong>本文中的所有内容均不会用于商业用途.</strong> </p><p>本文所用资料是我从网上搜寻和积累的. 本文的某些部分是拿资料直接cv之后改了两下扔进去的<br>我在网上冲浪的时候遇到自己感觉不错的文章和资料有时会把它们节选后存下来. 时间一长, 它们干脆就成了我pc硬盘中某些阴暗角落里的住民, 常年不见天日.<br>这时候麻烦又来了: 我经常忘记加作者和链接tag,  所以时间一长, 部分信息来源已不可考, 连我自己都忘了.<br><strong>所以如果您发现这篇文章中的某一部分很眼熟, 那大概率就是缝的您的.请联系我注明出处!(当然让我删了也行)</strong></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片来源</title>
    <link href="/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/"/>
    <url>/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>本blog中的部分图片来自本人喜爱的几位插画师&#x2F;漫画家<br>在这里给感兴趣的朋友指一下路.<br>随着blog的更新所用图片可能会有变化, 但本文会进行留档. </p><h2 id="场景类"><a href="#场景类" class="headerlink" title="场景类"></a>场景类</h2><img src="/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/t01.png" class="" title="t01"><p>pixiv ID: 74125530</p><ul><li>illustrator: あきま</li><li><a href="https://www.pixiv.net/users/19301797/artworks">pixiv</a><br>あきま老师有时喜欢在画作里插入一些很有趣的原创机体, 比如本作中的mig-21(可能更像su-17&#x2F;22一点?)类似物.<br>这位画师在b站也有账号. 可以搜索: 明正AkimatutiX</li></ul><img src="/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/t02.png" class="" title="t02"><p>pixiv ID: 59198089</p><ul><li>illustrator: あきま</li><li><a href="https://www.pixiv.net/users/19301797/artworks">pixiv</a><br>(私货)同样是あきま老师的作品. 曾经被我拿来做了两年的头像.</li></ul><h2 id="人物类"><a href="#人物类" class="headerlink" title="人物类"></a>人物类</h2><img src="/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/t04.png" class="" title="t04"><ul><li>illustrator: 村田蓮爾</li><li><a href="https://twitter.com/Murata_Range">Twitter</a><br>本人最喜欢的一位插画家, 业界老资历.<br>这张是《最终流放:银翼的法姆》的官绘.<br><del>高三填报志愿差点追随村田蓮爾老师的轨迹学了id</del></li></ul><img src="/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/t05.png" class="" title="t05"><p>pixiv ID: 83246376</p><ul><li>illustrator:  冬野カモメ</li><li><a href="https://www.pixiv.net/users/42910565">pixiv</a><br>很喜欢冬野カモメ老师的色铅笔画</li></ul><h2 id="其它类"><a href="#其它类" class="headerlink" title="其它类"></a>其它类</h2><img src="/2024/03/07/%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90/t03.png" class="" title="t03"><p>pixiv ID: 114189893</p><ul><li>illustrator: Zimri . Ezekie</li><li><a href="https://www.pixiv.net/users/22531933">pixiv</a><br>作为文章的默认头图使用.<br>我最喜欢的抽象艺术流派是活跃于上世纪初的构成主义&#x2F;至上主义. 这位画师的作品很有这种风格.<br>不过需要注意的是, 这位老师的ID经常改动, 本文中的信息时效性会有不足.</li></ul><h2 id="请注意…"><a href="#请注意…" class="headerlink" title="请注意…"></a>请注意…</h2><p>本blog中的所有图片均不会用于商业用途. 但如果您不认为自己的作品应该出现在这里, 请联系我删除.</p>]]></content>
    
    
    <categories>
      
      <category>art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>art</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/03/06/0306/"/>
    <url>/2024/03/06/0306/</url>
    
    <content type="html"><![CDATA[<p>这是测试文章!<br>test</p><img src="/2024/03/06/0306/test.png" class="" title="图片引用方法一">]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
